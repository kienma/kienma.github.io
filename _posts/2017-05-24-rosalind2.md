---
layout: post
title: Finding a Consensus Sequence and Generating a Consensus Matrix 
--- 

This post focuses on finding a consensus sequence and how I built a method in Scala to do so. I built this method as part of my 
bioinformatics explorations through [Rosalind](http://rosalind.info/). The Rosalind problem with code 
[CONS](http://rosalind.info/problems/cons/) focuses on creating an alignment sequence for DNA sequences. 
However, my code generalizes this to any characters, in which the analyzer chooses a 
biological alphabet. This lends itself to consensus sequence finding for proteins and RNAs, in addition to any other biological sequences 
that can be represented by symbols. The code is currently limited to a set of sequences that are all equal length.

I approached the problem by abstracting this as a character counting problem. For my bioinformatics focus, my Scala `class` uses 
a series of FASTA sequences as its only parameter. In the future, I hope to implement a simpler alphabet input for easier usability. 
The problem is interested only in the sequences, and as such, my code first strips out the sequence ID from the FASTA data. I did so 
using `scala.filter()`. The instance then creates a sequences only as `val S`. This `val S` is used throughout the rest of analysis. 

The rest of my code relies on an `aligned character count` function, which I wrote as `ANC`:
```scala
  def ANC(character:Char,I:Int):Int={
    var count:Int = 0
    val L = S.length-1
    for (i <- 0 to L){
      val C = S(i)(I) // S, sequences only (see the paragraph 2)
      if (C == character){
        count += 1 
      }
    }
    return count
  }
```
This function counts the number of times at index `I` that a particular `character` appears in each sequence in `S`. 
It returns the number of times as an integer, `count`. 

Since `ANC` can be used with an arbitrary `character`, I expanded the analysis for an arbitrary set of characters, `characters`. This 
is the biological alphabet of interest. I then created a function that takes in a biological alphabet and returns the number of times 
counted at each index in the aligned sequences. 
```scala
  def charCount(characters:Vector[Char]):Vector[Vector[Int]]={
    var counts:Vector[Vector[Int]] = Vector() // vector of the counts for each character in the biological alphabet
    val L = S(0).length-1
    for (i <- 0 to L){
      var nuc:Vector[Int] = Vector() // since the problem focuses on nucleotides, "nuc" stands for "nucleotides", though it generalizes
      for (j <- characters){
        val anc = ANC(j,i)
        nuc = nuc:+anc
      }
      counts = counts:+nuc
    }
    return counts 
  }
```
The `Vector[Vector[Int]]` that the function returns is denoted by `counts`. Each index corresponds to the index of the sequences.
Second, each element of `counts` contains the number of times each character in `characters` is counted and 
stores this information with corresponding indices for each element in `characters`. 

The consensus sequence is then derived from analysis of `charCount`. Namely, it determines the character that appears the most for each 
index in the aligned sequences and concatenates that character to string `consensus`. The function that finds the consensus sequence 
also takes the biological alphabet of interest, `characters`, as its parameter. 
```scala
  def consensus_sequence(characters:Vector[Char]):String={
    var consensus:String = ""
    val counts = charCount(characters)
    for (i <- 0 to counts.length-1){
      val I = counts(i).indexOf(counts(i).max)
      val C = characters(I)
      consensus += C
    }
    return consensus
  }
```

Finally, the alignment matrix is a displayed output. 

My full code can be found on my Github. [The link can be found here](https://github.com/kienma/ROSALIND/blob/master/CONS.scala). 
Thanks for reading! 
